\section{AC-BlockDFL System Design}
\label{sec:system_design}

We now present Audit-driven Committee BlockDFL (AC-BlockDFL), a framework that reconciles the efficiency demands of federated learning with provable economic security guarantees. Our design philosophy centers on a fundamental insight: \emph{liveness and security need not be coupled}. Traditional Byzantine fault-tolerant systems conflate these properties, requiring full consensus before any state change. AC-BlockDFL decouples them by assigning efficiency (liveness) to the committee while distributing security enforcement across the entire network through asynchronous auditing.

\subsection{Design Philosophy}
\label{sec:design_philosophy}

The core tension in blockchain-based federated learning stems from misaligned finality requirements. Financial systems demand immediate, irrevocable correctness for every transaction, necessitating synchronous consensus. However, federated learning's iterative nature---where single-round deviations can be corrected through subsequent training---creates design space for a fundamentally different approach.

AC-BlockDFL exploits this observation through \emph{optimistic execution}: the committee's consensus triggers immediate model updates, while rigorous verification proceeds asynchronously in the background. Security emerges not from preventing malicious behavior \emph{a priori}, but from ensuring that any detectable misbehavior incurs economic penalties that far exceed potential gains. This shifts the security model from threshold-based guarantees (requiring honest majorities) to \emph{economic security} (requiring only that attackers be rational).

\subsection{System Architecture and Workflow}
\label{sec:workflow}

AC-BlockDFL extends the BlockDFL committee model with three architectural innovations: (1) a fourth participant role---the \emph{Challenger}---responsible for post-hoc auditing; (2) off-chain storage integration via IPFS to reduce on-chain overhead from $O(\text{ModelSize})$ to $O(\text{HashSize})$; and (3) an asynchronous audit window that enables network-wide arbitration without blocking normal operation. Figure~\ref{fig:ac_blockdfl_arch} illustrates the complete workflow.

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{figures/utils/Challenge-Augmented-Committee-Architecture.drawio.png}
  \caption{AC-BlockDFL System Architecture and Workflow. The committee (Validators $\mathcal{V}$) performs optimistic execution while the Challenger network performs asynchronous auditing.}
  \label{fig:ac_blockdfl_arch}
\end{figure}

\paragraph{Instant Update Protocol.}
Algorithm~\ref{alg:ac_blockdfl_execution} formalizes the protocol's ``happy path.'' Each round proceeds through four phases: (1)~\emph{Role Assignment}---stake-weighted random selection determines validators $\mathcal{V}$, aggregators $\mathcal{A}$, and update providers $\mathcal{U}$ using the previous block hash as randomness source; (2)~\emph{Training and Off-chain Storage}---providers train locally, aggregators collect updates into proposals, upload to IPFS, and submit Content Identifiers (CIDs) on-chain; (3)~\emph{Consensus and Instant Commit}---validators retrieve proposals via CIDs, verify data availability, execute Krum scoring~\cite{blanchard2017machine}, and vote via PBFT. The winning model $w_{r+1}$ is committed \emph{immediately} upon achieving $>\frac{2}{3}$ committee agreement; (4)~\emph{Audit Window Opens}---the asynchronous challenge period begins, with participating nodes pinning relevant IPFS data for its duration.

\begin{algorithm}[t]
\caption{AC-BlockDFL Execution Protocol (Instant Update)}
\label{alg:ac_blockdfl_execution}
\begin{algorithmic}[1]
\Require Round $r$, stake-weighted nodes $\mathcal{N}$
\Ensure Updated global model $w_{r+1}$
\State \textbf{Phase 1 --- Role Assignment:} Select $\mathcal{V}, \mathcal{A}, \mathcal{U} \subset \mathcal{N}$ via stake-weighted randomness.
\State \textbf{Phase 2 --- Training \& Off-chain Storage:} Each $u \in \mathcal{U}$ trains on local data; $a \in \mathcal{A}$ aggregates into proposal $p_a$.
\State \hspace{1.1em} Upload $p_a$ to IPFS $\rightarrow$ obtain $\text{CID}_a$; submit $\text{CID}_a$ on-chain.
\State \textbf{Phase 3 --- On-chain Consensus \& Instant Update:} $\mathcal{V}$ retrieves $\{p_a\}$ via CIDs, verifies data availability, and runs Krum.
\State \hspace{1.1em} Vote via PBFT. \textbf{Commit} $w_{r+1}$ immediately upon majority. 
\State \hspace{1.1em} Record winning $\text{CID}^*$ and voter identities on-chain. Dispense round rewards.
\State \textbf{Phase 4 --- Audit Window Opens:} Asynchronous challenge period begins. Nodes pin IPFS data.
\end{algorithmic}
\end{algorithm}

The critical design choice is \emph{immediate commitment}: unlike systems that impose confirmation delays, AC-BlockDFL prioritizes liveness by allowing the committee's decision to take effect instantly. Security is enforced through the challenge mechanism described next.

\subsection{Challenge Mechanism}
\label{sec:challenge_mechanism}

The Challenger role is open to any network participant willing to stake the required deposit, ensuring surveillance power remains distributed rather than concentrated. Challengers continuously monitor on-chain records, retrieve proposals from IPFS via their CIDs, and independently re-execute the Krum algorithm. Since Krum is fully deterministic---identical inputs yield identical outputs---any discrepancy between the committee's selection and the correct result constitutes irrefutable evidence of misbehavior.

\paragraph{Challenge Protocol.}
Algorithm~\ref{alg:ac_blockdfl_challenge} details the challenge flow. Upon detecting a mismatch, a challenger submits a challenge transaction with deposit $D_{\text{challenge}}$, triggering network-wide arbitration. All nodes download the relevant IPFS data and independently verify. If $>\frac{2}{3}$ of the network confirms malicious consensus, colluding committee members face \emph{full stake slashing}, with rewards distributed to the challenger and honest participants. Failed challenges result in deposit forfeiture, preventing denial-of-service attacks through spurious challenges.

\begin{algorithm}[t]
\caption{Asynchronous Challenge Mechanism}
\label{alg:ac_blockdfl_challenge}
\begin{algorithmic}[1]
\Require Challenger $ch$, on-chain CID references, IPFS store
\Ensure Punishment for malicious committee actions
\State $ch$ retrieves proposal CIDs from chain, downloads $\{p_a\}$ from IPFS.
\State $ch$ re-executes Krum on $\{p_a\}$.
\If{outcome mismatches committed $w_{r+1}$}
    \State $ch$ posts challenge transaction with deposit $D_{\text{challenge}}$.
    \State \textbf{Arbitration Triggered:} All consensus nodes verify independently.
    \If{malicious consensus confirmed by $> \frac{2}{3}$ of network}
        \State \textbf{Slash} full stake of colluding validators $\mathcal{V}_{\text{mal}}$.
        \State Reward Challenger $ch$; distribute remainder to honest participants.
        \State \textit{// Note: Model $w_{r+1}$ is NOT reverted.}
    \Else
        \State Forfeit $ch$'s deposit $D_{\text{challenge}}$.
    \EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\paragraph{Dynamic Staking Model.}
A key design principle is that all economic parameters derive from \emph{endogenous} system metrics, avoiding external oracle dependencies that could become attack vectors. The maximum rational gain from committee capture is bounded by the round reward $R_{\text{round}}$. We therefore define the slashing amount as $D_{\text{slash}} = \lambda \times R_{\text{round}}$ ($\lambda \gg 1$). In our implementation, an effective $\lambda \approx 100$ means a single slashing event costs the equivalent of 100 rounds of honest participation, eliminating the economic incentive for rational attackers. The challenge deposit $D_{\text{challenge}}$ also scales dynamically with $R_{\text{round}}$, self-adjusting to network economic conditions.

\paragraph{No-Rollback Policy.} \label{sec:no_rollback}
When arbitration confirms misbehavior, AC-BlockDFL slashes malicious actors but \emph{does not revert} the committed model update. Rollback conflicts with blockchain finality guarantees and invites long-range attacks. Furthermore, rollback would require reverting potentially hundreds of subsequent blocks due to arbitration delays. AC-BlockDFL instead employs \emph{forward correction}: severe economic penalties act as a lethal deterrent against systematic attacks, while subsequent honest training rounds gradually correct the mathematical deviation of any isolated malicious update.

\subsection{Efficiency and Overhead Analysis}
\label{sec:efficiency_analysis}

A fundamental dilemma in traditional committee-based consensus is the coupling of security and committee size: augmenting the probability of an honest majority necessitates expanding the committee, severely penalizing communication overhead. AC-BlockDFL resolves this by shifting the security burden to the economic protocol.

\paragraph{Communication Complexity.}
Traditional BlockDFL relies exclusively on threshold security (i.e., driving the probability of committee capture $p_{\text{risk}}$ to near zero). In a network of $N=100$ nodes with an adversarial fraction $f=0.3$, ensuring $p_{\text{risk}} < 0.01$ mathematically requires a committee size of $C \geq 9$. This produces a constant per-round PBFT communication complexity of $O(C^2) = O(81)$. This overhead acts as a ``preventative premium'' exacted uniformly across every round, regardless of whether an attack actually occurs.

In contrast, by enforcing economic security, AC-BlockDFL maintains deterrence even with a smaller committee. Using $C=7$, the routine communication complexity drops to $O(49)$, a reduction of 39.5\%. The heavy $O(N^2)$ PBFT overhead of network-wide arbitration is conditionally triggered only upon an explicit challenge round. The expected communication complexity converges to:
\begin{equation}
E[\text{Comm}] = (1-p) \cdot O(C^2) + p \cdot \left(O(C^2) + O(N^2)\right) = O(C^2) + p \cdot O(N^2)
\end{equation}
Because the immense slashing penalty eliminates the rational incentive for PCCA, the objective probability of an attack $p$ approaches 0 under steady-state equilibrium. The expected communication cost is effectively the routine $O(C^2)$, operating on a drastically reduced constant factor.

\paragraph{Storage Overhead.}
Storing raw neural network gradients directly on an immutable ledger guarantees ledger bloat. AC-BlockDFL utilizes a decentralized pinning strategy over IPFS. During the \emph{challenge window} (e.g., $W$ subsequent blocks), nodes are mathematically obligated to pin the IPFS chunks to guarantee data availability for potential challengers. Once the window expires uninterrupted, nodes safely unpin the historical epoch's parameters. This lifecycle management slashes permanent on-chain storage requirements from $O(\text{ModelSize})$ to $O(\text{HashSize})$ (a 32-byte CID), preserving decentralization without burdening node operators with unsustainable disk requirements.