\section{AC-BlockDFL System Design}
\label{sec:system_design}

Traditional Byzantine fault-tolerant (BFT) consensus mechanisms provide robust security guarantees but their $O(N^2)$ communication complexity inherently conflicts with the highly iterative nature of federated learning. As analyzed in Section~\ref{sec:threat_model}, existing committee-based approaches mitigate this overhead but introduce severe structural vulnerabilities: small committees are susceptible to progressive stake accumulation, and their reliance on honest-majority assumptions fails to deter rational, strategic attackers. 

To break this deadlock, we introduce Audit-driven Committee BlockDFL (AC-BlockDFL). This framework builds upon the baseline BlockDFL model but fundamentally shifts the paradigm from ``threshold security'' to ``economic security'' through asynchronous auditing and internal slashing protocols.

\subsection{Design Philosophy}
\label{sec:design_philosophy}

The core design philosophy of AC-BlockDFL stems from re-evaluating the relationship between a blockchain's state finality and the iterative training characteristics of federated learning. Financial transaction systems demand immediate, irrevocable correctness for every transaction because any error could lead to permanent asset loss; this forces traditional blockchains to achieve network-wide consensus \emph{before} any state change. However, federated learning operates through multiple rounds of iterative refinement. A single round's deviation can be naturally corrected by subsequent training rounds.

This observation creates the design space to decouple synchronous execution from correctness verification. AC-BlockDFL adopts an \emph{optimistic execution} philosophy: it allows the system to immediately commit model updates once the small committee reaches consensus, while rigorous correctness verification is deferred to a non-blocking, asynchronous background audit. Security is maintained not by preventing malicious behavior upfront, but by ensuring that any attempt to manipulate committee consensus faces an economic penalty that exponentially exceeds any potential gain, thereby eliminating the economic incentive for attacks in a game-theoretic setting.

\subsection{System Architecture and Workflow}
\label{sec:workflow}

AC-BlockDFL preserves the foundational training workflow of BlockDFL---including the localized training by Update Providers, proposal generation by Aggregators, and Krum-based~\cite{blanchard2017machine} scoring via PBFT by Validators. However, it introduces three critical architectural extensions:

\begin{enumerate}
    \item \textbf{The Challenger Role:} A fourth participant role subject to open-access principles. Any network node willing to stake the required deposit can act as a Challenger for a given round. This ensures supervisory power remains highly decentralized. Challengers continuously monitor on-chain records, independently re-execute the deterministic Krum algorithm, and compare their results against the committee's committed global update.
    \item \textbf{Off-chain Storage Integration:} To prevent ledger bloat, AC-BlockDFL offloads the heavy model gradients to the InterPlanetary File System (IPFS), recording only Content Identifiers (CIDs) and metadata on-chain. This reduces on-chain storage complexity from $O(\text{ModelSize})$ to $O(\text{HashSize})$. To ensure data availability during audits, nodes pin the relevant IPFS data for the duration of a defined Challenge Window.
    \item \textbf{Execute-then-Audit Paradigm:} Unlike BlockDFL where committee decisions are final without recourse, AC-BlockDFL commits the model immediately but simultaneously opens an asynchronous audit window. This retains high liveness while preserving the ability to trigger a network-wide arbitration if anomalies are detected, effectively democratizing oversight to the entire network.
\end{enumerate}

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{figures/utils/Challenge-Augmented-Committee-Architecture.drawio.png}
  \caption{AC-BlockDFL System Architecture and Workflow. The committee performs optimistic execution while the Challenger network performs asynchronous auditing.}
  \label{fig:ac_blockdfl_arch}
\end{figure}

\paragraph{Instant Update Protocol.}
Algorithm~\ref{alg:ac_blockdfl_execution} formalizes the protocol's ``happy path.'' During Phase 1, role assignment is deterministically computed by all nodes based on stake-weighted randomness derived from the previous block hash. In Phase 2, aggregators upload aggregated proposals to IPFS and submit the resulting CIDs on-chain. In Phase 3, the Validator committee retrieves these proposals, executes Krum scoring, and votes via PBFT. The winning model $w_{r+1}$ is committed \emph{immediately} upon achieving $>2/3$ committee agreement. Finally, Phase 4 initiates the asynchronous challenge window.

\begin{algorithm}[t]
\caption{AC-BlockDFL Execution Protocol (Instant Update)}
\label{alg:ac_blockdfl_execution}
\begin{algorithmic}[1]
\Require Round $r$, Total Stake Weighted Nodes $\mathcal{N}$
\Ensure Updated Global Model $w_{r+1}$
\State \textbf{Phase 1 --- Role Assignment:} Select $\mathcal{V}, \mathcal{A}, \mathcal{U} \subset \mathcal{N}$ via stake-weighted randomness.
\State \textbf{Phase 2 --- Training \& Off-chain Storage:} Each $u \in \mathcal{U}$ trains on local data; $a \in \mathcal{A}$ aggregates into proposal $p_a$.
\State \hspace{1.1em} Upload $p_a$ to IPFS $\rightarrow$ obtain $\text{CID}_a$; submit $\text{CID}_a$ on-chain.
\State \textbf{Phase 3 --- On-chain Consensus \& Instant Update:} $\mathcal{V}$ retrieves $\{p_a\}$ via CIDs, verifies data availability, and runs Krum.
\State \hspace{1.1em} Vote via PBFT. \textbf{Commit} $w_{r+1}$ immediately upon majority. 
\State \hspace{1.1em} Record winning $\text{CID}^*$ and voter identities on-chain. Dispense round rewards.
\State \textbf{Phase 4 --- Audit Window Opens:} Asynchronous challenge period begins. Nodes pin IPFS data.
\end{algorithmic}
\end{algorithm}

\subsection{Asynchronous Audit and Challenge Mechanism}
\label{sec:challenge_mechanism}

The asynchronous audit mechanism entirely decouples synchronous verification from execution. By shifting the strict correctness validation into a non-blocking background process, the system achieves maximum throughput without sacrificing long-term security.

\paragraph{Challenge Trigger Logic.}
Algorithm~\ref{alg:ac_blockdfl_challenge} details the challenge execution flow. The trigger logic relies heavily on the profound decoupling of determinism and data transparency. Because Krum is strictly deterministic, a challenger locally executing the algorithm on identical IPFS inputs will inevitably produce the objectively correct output. Any deviation by the committee is thus easily recognizable.

When a challenger detects a discrepancy, they submit a challenge transaction enclosed with a deposit $D_{\text{challenge}}$. This deposit serves two critical purposes: (1) it acts as a defensive barrier against Denial-of-Service attacks, preventing malicious actors from spamming invalid challenges and exhausting network resources; and (2) it guarantees compensation for the computational and data-transfer overhead incurred by the entire network during the arbitration process, thereby solving the classic decentralized oversight motivation gap. Once triggered, the entire network downloads the proposals and executes Krum. If $>2/3$ confirm the misbehavior, colluding committee members suffer complete stake slashing.

\paragraph{Slashed Funds Distribution.}
The distribution of confiscated funds follows a stringent incentive compatibility design. A significant proportion of the slashed stake is awarded directly to the Challenger. This substantial bounty ensures that monitoring the network remains economically attractive, encouraging a robust ecosystem of independent auditors. The remaining slashed funds are distributed among the honest Update Providers who submitted valid gradients during the compromised round, as well as the Validator nodes that actively participated in the arbitration consensus. This broad distribution not only compensates honest participants for potential losses incurred during the attack but also cultivates a culture of collective supervision, firmly distributing the governance power across the entire network.

\begin{algorithm}[t]
\caption{Asynchronous Challenge Mechanism}
\label{alg:ac_blockdfl_challenge}
\begin{algorithmic}[1]
\Require Challenger $ch$, on-chain CID references, IPFS store
\Ensure Punishment for malicious committee actions
\State $ch$ retrieves proposal CIDs from chain, downloads $\{p_a\}$ from IPFS.
\State $ch$ re-executes Krum on $\{p_a\}$.
\If{outcome mismatches committed $w_{r+1}$}
    \State $ch$ posts challenge transaction with deposit $D_{\text{challenge}}$.
    \State \textbf{Arbitration Triggered:} All consensus nodes verify independently.
    \If{malicious consensus confirmed by $> 2/3$ of network}
        \State \textbf{Slash} full stake of colluding validators $\mathcal{V}_{\text{mal}}$.
        \State Reward Challenger $ch$; distribute remainder to honest participants.
        \State \textit{// Note: Model $w_{r+1}$ is NOT reverted.}
    \Else
        \State Forfeit $ch$'s deposit $D_{\text{challenge}}$.
    \EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\paragraph{Endogenous Dynamic Staking Model.}
A decentralized system's core parameters must derive from verifiable internal metrics rather than external oracles, which introduce vulnerabilities (e.g., price manipulation or latency). AC-BlockDFL anchors its penalty pricing exclusively to internal economic activity. 

Under the rational game theory assumption, the maximum immediate gain from committee capture is bounded by the round reward $R_{\text{round}}$. To build an impenetrable economic deterrent, the slashing penalty $D_{\text{slash}}$ must dynamically shadow $R_{\text{round}}$:
\begin{equation}
D_{\text{slash}} = \lambda \times R_{\text{round}}, \quad \lambda \gg 1
\end{equation}
By setting $\lambda \approx 100$, a single slashing event perfectly wipes out the equivalent of 100 rounds of honest participation. 

Similarly, the challenge deposit $D_{\text{challenge}}$ must simultaneously satisfy economic sustainability and accessibility. If a challenge fails, the forfeited deposit must cover the marginal computational cost $\epsilon$ of the $N_{\text{arb}}$ nodes participating in arbitration (i.e., $D_{\text{challenge}} \geq N_{\text{arb}} \cdot \epsilon$). Practically, $D_{\text{challenge}}$ can be defined as $\alpha \times R_{\text{round}}$. Since $R_{\text{round}}$ scales with network economic scale, the costs dynamically adjust to all market conditions.

\paragraph{State Finality and No-Rollback Policy.} \label{sec:no_rollback}
When arbitration confirms malicious consensus, AC-BlockDFL executes economic slashing but deliberately \emph{does not} revert the committed model update. This design choice addresses the fundamental conflict between state rollback and the core blockchain principle of immutability. Reverting historical states destroys the finality of all subsequent blocks, leaving the system highly vulnerable to \emph{Long-Range Attacks} where adversaries rewrite history from a deeply buried block. In a federated learning context, arbitration latency means that by the time an early round is deemed malicious, tens or hundreds of subsequent blocks may have been appended. 

Furthermore, rolling back the global state demands extreme coordination complexity. It requires all distributed nodes to simultaneously revert to a historical snapshot and discard immense amounts of valid computational work, a process that becomes exponentially more difficult as the chain grows. AC-BlockDFL instead embraces a ``Forward Correction'' strategy: the severe economic penalty liquidates the attacker's future governance influence, cutting off the attack vector permanently. The minor mathematical deviation introduced by a single anomalous epoch is naturally digested and rectified by the iterative self-healing property of subsequent honest training rounds. 

\subsection{Efficiency and Overhead Analysis}
\label{sec:efficiency_analysis}

By shifting the security paradigm from threshold-based to economic-based, AC-BlockDFL successfully decouples the stringent relationship between security guarantees and committee size, yielding substantial efficiency dividends across communication and storage.

\paragraph{Communication Complexity.}
In standard BlockDFL deployments, suppressing the attack probability $p_{\text{risk}}$ near zero obligates the system to maintain a large committee. For instance, in a 100-node network with a $30\%$ adversarial fraction, maintaining $p_{\text{risk}} < 0.01$ mathematically dictates $C \geq 9$. The resulting PBFT communication complexity acts as a rigid, preventative premium $O(81)$ exacted uniformly across every single round, regardless of whether the network is under attack.

AC-BlockDFL neutralizes this overhead by ensuring that even if the committee is compromised, attackers cannot profit. Consequently, the mechanism satisfies foundational security constraints with a smaller committee size $C=7$, dropping the baseline communication complexity to $O(49)$---a nearly $40\%$ reduction. The heavy network-wide PBFT arbitration cost $O(N^2)$ is strictly conditional. In equilibrium, because the penalty mechanism eliminates the exploit incentive, the objective probability of an attack $p$ approaches 0. The expected communication complexity seamlessly converges to standard committee levels:
\begin{equation}
E[\text{Comm}] = (1-p) \cdot O(C^2) + p \cdot \left(O(C^2) + O(N^2)\right) = O(C^2) + p \cdot O(N^2)
\end{equation}
This establishes a highly efficient ``pay-as-you-go'' security model rather than a perpetual static penalty.

\paragraph{Storage Overhead.}
Recording pristine neural network gradients on an immutable ledger guarantees exponential bloat. While IPFS cleanly mitigates on-chain storage, AC-BlockDFL uniquely incorporates a strict lifecycle management and pinning strategy. During the challenge window, validator nodes are mathematically obligated to pin the IPFS chunks, ensuring data availability for prospective challengers. However, the moment the challenge Time-To-Live (TTL) window expires uninterrupted, nodes safely unpin the historical epoch's parameters. This ephemeral storage footprint ensures the system scales gracefully, slashing permanent on-chain storage mapping from $O(\text{ModelSize})$ completely down to $O(\text{HashSize})$, preserving systemic decentralization without burdening node operators with unsustainable disk requirements.